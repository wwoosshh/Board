// src/api/AuthApi.js (ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏÉÅÌÉú Í∞êÏßÄ Ìñ•ÏÉÅ)
import axios from 'axios';

// üåê HTTPÎ°ú Îã§Ïãú Î≥ÄÍ≤Ω (HTTPS ÎåÄÏã†)
const BASE_URL = process.env.NODE_ENV === 'production' 
  ? '/api'  
  : 'http://localhost:5159/api';
console.log('üåê ÌòÑÏû¨ BASE_URL:', BASE_URL);

// Axios Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
const apiClient = axios.create({
  baseURL: BASE_URL,
  timeout: 10000, // 10Ï¥à ÌÉÄÏûÑÏïÑÏõÉ
});

// ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏÉÅÌÉú Ï†ÑÏó≠ Î≥ÄÏàò
let isServerConnected = true;
let serverConnectionCallbacks = [];

// ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏÉÅÌÉú Î≥ÄÍ≤Ω Ïãú Ìò∏Ï∂úÎê† ÏΩúÎ∞± Îì±Î°ù
export const onServerConnectionChange = (callback) => {
  serverConnectionCallbacks.push(callback);
  return () => {
    serverConnectionCallbacks = serverConnectionCallbacks.filter(cb => cb !== callback);
  };
};

// ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏÉÅÌÉú ÏïåÎ¶º
const notifyServerConnectionChange = (connected, error = null) => {
  const wasConnected = isServerConnected;
  isServerConnected = connected;
  
  if (wasConnected !== connected) {
    serverConnectionCallbacks.forEach(callback => {
      try {
        callback(connected, error);
      } catch (err) {
        console.error('ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏÉÅÌÉú ÏΩúÎ∞± Ïò§Î•ò:', err);
      }
    });
  }
};

// ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïò§Î•ò Í∞êÏßÄ Ìï®Ïàò
const detectServerConnectionError = (error) => {
  if (!error) return false;
  
  // ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò Ìå®ÌÑ¥Îì§
  const networkErrorPatterns = [
    'Network Error',
    'ECONNREFUSED',
    'ENOTFOUND', 
    'ETIMEDOUT',
    'ECONNRESET',
    'ERR_NETWORK',
    'ERR_INTERNET_DISCONNECTED'
  ];
  
  // Ïò§Î•ò Î©îÏãúÏßÄ Ï≤¥ÌÅ¨
  const errorMessage = error.message || '';
  const isNetworkError = networkErrorPatterns.some(pattern => 
    errorMessage.includes(pattern)
  );
  
  // Ïò§Î•ò ÏΩîÎìú Ï≤¥ÌÅ¨
  const errorCode = error.code || '';
  const isConnectionError = networkErrorPatterns.some(pattern => 
    errorCode.includes(pattern)
  );
  
  // ÌÉÄÏûÑÏïÑÏõÉ Ï≤¥ÌÅ¨
  const isTimeout = error.code === 'ECONNABORTED' || errorMessage.includes('timeout');
  
  // ÏÑúÎ≤Ñ ÏùëÎãµÏù¥ ÏïÑÏòà ÏóÜÎäî Í≤ΩÏö∞
  const noResponse = !error.response;
  
  return isNetworkError || isConnectionError || isTimeout || noResponse;
};

// ÌÜ†ÌÅ∞ Í∞±Ïã† Ï§ëÏù∏ÏßÄ ÌôïÏù∏ÌïòÎäî ÌîåÎûòÍ∑∏
let isRefreshing = false;
let refreshSubscribers = [];

// ÌÜ†ÌÅ∞ Í∞±Ïã† ÎåÄÍ∏∞ Ï§ëÏù∏ ÏöîÏ≤≠Îì§ÏùÑ Ï≤òÎ¶¨ÌïòÎäî Ìï®Ïàò
const subscribeTokenRefresh = (cb) => {
  refreshSubscribers.push(cb);
};

const onRefreshed = (token) => {
  refreshSubscribers.forEach((cb) => cb(token));
  refreshSubscribers = [];
};

// JWT ÌÜ†ÌÅ∞ ÎîîÏΩîÎî© (ÎßåÎ£å ÏãúÍ∞Ñ ÌôïÏù∏Ïö©)
const decodeJWT = (token) => {
  try {
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
      return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
    }).join(''));
    return JSON.parse(jsonPayload);
  } catch (error) {
    console.error('JWT ÎîîÏΩîÎî© Ïò§Î•ò:', error);
    return null;
  }
};

// ÌÜ†ÌÅ∞ ÎßåÎ£å ÌôïÏù∏
const isTokenExpired = (token) => {
  if (!token) return true;
  
  const decoded = decodeJWT(token);
  if (!decoded || !decoded.exp) return true;
  
  const currentTime = Date.now() / 1000;
  const bufferTime = 60; // 1Î∂Ñ Î≤ÑÌçº
  
  return decoded.exp < (currentTime + bufferTime);
};

// ÌÜ†ÌÅ∞ ÎßåÎ£åÍπåÏßÄ ÎÇ®ÏùÄ ÏãúÍ∞Ñ (Î∂Ñ)
const getTokenRemainingTime = (token) => {
  if (!token) return 0;
  
  const decoded = decodeJWT(token);
  if (!decoded || !decoded.exp) return 0;
  
  const currentTime = Date.now() / 1000;
  const remainingSeconds = decoded.exp - currentTime;
  
  return Math.max(0, Math.floor(remainingSeconds / 60));
};

// ÏûêÎèô Î°úÍ∑∏ÏïÑÏõÉ Î∞è ÏïåÎ¶º
const handleTokenExpiration = (message = 'Î°úÍ∑∏Ïù∏Ïù¥ ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§. Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥Ï£ºÏÑ∏Ïöî.') => {
  // ÌÜ†ÌÅ∞ Ï†ïÎ¶¨
  clearAuthData();
  
  // ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÏïåÎ¶º
  if (window.showTokenExpiredNotification) {
    window.showTokenExpiredNotification(message);
  } else {
    alert(message);
  }
  
  // 3Ï¥à ÌõÑ Î°úÍ∑∏Ïù∏ ÌéòÏù¥ÏßÄÎ°ú Ïù¥Îèô
  setTimeout(() => {
    window.location.href = '/login';
  }, 3000);
};

// ÏöîÏ≤≠ Ïù∏ÌÑ∞ÏÖâÌÑ∞ - Authorization Ìó§Îçî Ï∂îÍ∞Ä Î∞è ÌÜ†ÌÅ∞ Ï≤¥ÌÅ¨
apiClient.interceptors.request.use(
  async (config) => {
    // Ïù∏Ï¶ùÏù¥ ÌïÑÏöîÏóÜÎäî Í≤ΩÎ°úÎäî Í±¥ÎÑàÎõ∞Í∏∞
    if (config.url.includes('/auth/')) {
      return config;
    }
    
    const token = getToken();
    
    if (token) {
      // ÌÜ†ÌÅ∞ ÎßåÎ£å Ï≤¥ÌÅ¨
      if (isTokenExpired(token)) {
        try {
          const newToken = await refreshTokenSilently();
          if (newToken) {
            config.headers.Authorization = `Bearer ${newToken}`;
          } else {
            throw new Error('ÌÜ†ÌÅ∞ Í∞±Ïã† Ïã§Ìå®');
          }
        } catch (error) {
          // ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïò§Î•òÏù∏ÏßÄ ÌôïÏù∏
          if (detectServerConnectionError(error)) {
            notifyServerConnectionChange(false, error);
            return Promise.reject(error);
          }
          
          handleTokenExpiration('ÏÑ∏ÏÖòÏù¥ ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§. Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥Ï£ºÏÑ∏Ïöî.');
          return Promise.reject(error);
        }
      } else {
        config.headers.Authorization = `Bearer ${token}`;
      }
    }
    
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// ÏùëÎãµ Ïù∏ÌÑ∞ÏÖâÌÑ∞ - ÌÜ†ÌÅ∞ ÎßåÎ£å Ïãú ÏûêÎèô Í∞±Ïã† Î∞è ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏÉÅÌÉú Í∞êÏßÄ
apiClient.interceptors.response.use(
  (response) => {
    // ÏÑ±Í≥µÏ†ÅÏù∏ ÏùëÎãµÏù¥Î©¥ ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
    notifyServerConnectionChange(true);
    return response;
  },
  async (error) => {
    const { config, response } = error;
    
    // ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïò§Î•ò Í∞êÏßÄ
    if (detectServerConnectionError(error)) {
      notifyServerConnectionChange(false, error);
      return Promise.reject(error);
    }
    
    // ÏÑúÎ≤Ñ Ïó∞Í≤∞ÏùÄ ÎêòÏßÄÎßå 5xx Ïò§Î•òÏù∏ Í≤ΩÏö∞
    if (response?.status >= 500) {
      notifyServerConnectionChange(true); // Ïó∞Í≤∞ÏùÄ ÎêòÏßÄÎßå ÏÑúÎ≤Ñ Ïò§Î•ò
    }
    
    if (response?.status === 401 && !config._retry) {
      if (isRefreshing) {
        // Ïù¥ÎØ∏ ÌÜ†ÌÅ∞ Í∞±Ïã† Ï§ëÏù¥Î©¥ ÎåÄÍ∏∞
        return new Promise((resolve) => {
          subscribeTokenRefresh((token) => {
            config.headers.Authorization = `Bearer ${token}`;
            resolve(apiClient(config));
          });
        });
      }

      config._retry = true;
      isRefreshing = true;

      try {
        const refreshTokenStr = getRefreshToken();
        if (!refreshTokenStr) {
          throw new Error('Refresh tokenÏù¥ ÏóÜÏäµÎãàÎã§.');
        }

        const response = await apiClient.post('/auth/refresh', { 
          refreshToken: refreshTokenStr 
        });
        const { accessToken, refreshToken: newRefreshToken } = response.data;
        
        setToken(accessToken);
        if (newRefreshToken) {
          setRefreshToken(newRefreshToken);
        }
        
        onRefreshed(accessToken);
        
        config.headers.Authorization = `Bearer ${accessToken}`;
        return apiClient(config);
      } catch (refreshError) {
        // ÌÜ†ÌÅ∞ Í∞±Ïã†ÎèÑ ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïò§Î•òÏù∏ÏßÄ ÌôïÏù∏
        if (detectServerConnectionError(refreshError)) {
          notifyServerConnectionChange(false, refreshError);
        } else {
          handleTokenExpiration('Ïù∏Ï¶ùÏù¥ ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§. Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥Ï£ºÏÑ∏Ïöî.');
        }
        return Promise.reject(refreshError);
      } finally {
        isRefreshing = false;
      }
    }

    return Promise.reject(error);
  }
);

// ÏûêÎèô ÌÜ†ÌÅ∞ Í∞±Ïã† (ÏöîÏ≤≠ Ï†Ñ Ìò∏Ï∂ú)
const refreshTokenSilently = async () => {
  try {
    const refreshTokenStr = getRefreshToken();
    if (!refreshTokenStr) {
      throw new Error('Refresh tokenÏù¥ ÏóÜÏäµÎãàÎã§.');
    }

    const response = await axios.post(`${BASE_URL}/auth/refresh`, { 
      refreshToken: refreshTokenStr 
    }, {
      timeout: 5000 // ÌÜ†ÌÅ∞ Í∞±Ïã†ÏùÄ ÏßßÏùÄ ÌÉÄÏûÑÏïÑÏõÉ
    });
    
    const { accessToken, refreshToken: newRefreshToken } = response.data;
    
    setToken(accessToken);
    if (newRefreshToken) {
      setRefreshToken(newRefreshToken);
    }
    
    return accessToken;
  } catch (error) {
    return null;
  }
};

// ÎÇòÎ®∏ÏßÄ Ìï®ÏàòÎì§ÏùÄ Í∏∞Ï°¥Í≥º ÎèôÏùºÌïòÍ≤å Ïú†ÏßÄ...
// (register, login, refreshToken, logout, setToken, getToken Îì±)

// ÏÇ¨Ïö©Ïûê Îì±Î°ù (ÌöåÏõêÍ∞ÄÏûÖ)
export const register = async (userData) => {
  try {
    const response = await apiClient.post('/auth/register', userData);
    return response.data;
  } catch (error) {
    // ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïò§Î•òÏù∏ÏßÄ ÌôïÏù∏
    if (detectServerConnectionError(error)) {
      notifyServerConnectionChange(false, error);
    }
    
    throw error;
  }
};

// ÏÇ¨Ïö©Ïûê Î°úÍ∑∏Ïù∏
export const login = async (credentials) => {
  try {
    const response = await apiClient.post('/auth/login', credentials);
    
    // ÏùëÎãµ Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞ ÌôïÏù∏
    const { accessToken, refreshToken, user } = response.data;
    
    if (!accessToken) {
      throw new Error('ÏÑúÎ≤ÑÏóêÏÑú AccessTokenÏùÑ Î∞õÏßÄ Î™ªÌñàÏäµÎãàÎã§.');
    }
    
    if (!refreshToken) {
      throw new Error('ÏÑúÎ≤ÑÏóêÏÑú RefreshTokenÏùÑ Î∞õÏßÄ Î™ªÌñàÏäµÎãàÎã§.');
    }
    
    if (!user) {
      throw new Error('ÏÑúÎ≤ÑÏóêÏÑú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Î•º Î∞õÏßÄ Î™ªÌñàÏäµÎãàÎã§.');
    }
    
    // ÌÜ†ÌÅ∞Îì§ Ï†ÄÏû•
    setToken(accessToken);
    setRefreshToken(refreshToken);
    setUser(user);
    
    // ÏûêÎèô ÌÜ†ÌÅ∞ Í∞±Ïã† ÌÉÄÏù¥Î®∏ ÏãúÏûë
    startTokenRefreshTimer();
    
    // ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
    notifyServerConnectionChange(true);
    
    return response.data;
  } catch (error) {
    // ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïò§Î•òÏù∏ÏßÄ ÌôïÏù∏
    if (detectServerConnectionError(error)) {
      notifyServerConnectionChange(false, error);
    }
    
    throw error;
  }
};

// Í∏∞Ï°¥Ïùò Îã§Î•∏ Ìï®ÏàòÎì§ÎèÑ Ïú†ÏßÄ (ÌÜ†ÌÅ∞ Í¥ÄÎ¶¨, Í∂åÌïú Ï≤¥ÌÅ¨ Îì±)
export const setToken = (token) => {
  localStorage.setItem('accessToken', token);
  console.log('üíæ Access Token Ï†ÄÏû•Îê®');
};

export const getToken = () => {
  return localStorage.getItem('accessToken');
};

export const setRefreshToken = (token) => {
  localStorage.setItem('refreshToken', token);
  console.log('üíæ Refresh Token Ï†ÄÏû•Îê®');
};

export const getRefreshToken = () => {
  return localStorage.getItem('refreshToken');
};

export const setUser = (user) => {
  localStorage.setItem('user', JSON.stringify(user));
};

export const getCurrentUser = () => {
  const userStr = localStorage.getItem('user');
  return userStr ? JSON.parse(userStr) : null;
};

export const clearAuthData = () => {
  localStorage.removeItem('accessToken');
  localStorage.removeItem('refreshToken');
  localStorage.removeItem('user');
  console.log('üóëÔ∏è Ïù∏Ï¶ù Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†úÎê®');
};

// Ïù∏Ï¶ù Ìó§Îçî ÏÑ§Ï†ï
export const authHeader = () => {
  const token = getToken();
  return token ? { Authorization: `Bearer ${token}` } : {};
};

// ÏÇ¨Ïö©ÏûêÍ∞Ä Î°úÍ∑∏Ïù∏ÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏ (ÌÜ†ÌÅ∞ Ïú†Ìö®ÏÑ± Ìè¨Ìï®)
export const isAuthenticated = () => {
  const token = getToken();
  if (!token) return false;
  
  // ÌÜ†ÌÅ∞Ïù¥ ÎßåÎ£åÎêòÏóàÏúºÎ©¥ false Î∞òÌôò
  if (isTokenExpired(token)) {
    console.log('üî¥ ÌÜ†ÌÅ∞ ÎßåÎ£åÎê® - Ïù∏Ï¶ù Ïã§Ìå®');
    return false;
  }
  
  return true;
};

// ÏÇ¨Ïö©Ïûê Ïó≠Ìï† ÌôïÏù∏
export const hasRole = (role) => {
  const user = getCurrentUser();
  return user && user.role === role;
};

// Í∂åÌïú Ï≤¥ÌÅ¨ Ìï®ÏàòÎì§
export const isAdmin = () => hasRole('ROLE_ADMIN');
export const isModerator = () => hasRole('ROLE_MODERATOR');
export const isManager = () => hasRole('ROLE_MANAGER');
export const isAdminOrAbove = () => hasRole('ROLE_ADMIN') || hasRole('ROLE_MANAGER');
export const isModeratorOrAbove = () => hasRole('ROLE_MODERATOR') || hasRole('ROLE_ADMIN') || hasRole('ROLE_MANAGER');

// ÌÜ†ÌÅ∞ Í∞±Ïã†
export const refreshToken = async () => {
  try {
    const refreshTokenStr = getRefreshToken();
    if (!refreshTokenStr) {
      throw new Error('Refresh tokenÏù¥ ÏóÜÏäµÎãàÎã§.');
    }

    const response = await apiClient.post('/auth/refresh', { 
      refreshToken: refreshTokenStr 
    });
    const { accessToken, refreshToken: newRefreshToken } = response.data;
    
    setToken(accessToken);
    if (newRefreshToken) {
      setRefreshToken(newRefreshToken);
    }
    
    // ÏûêÎèô ÌÜ†ÌÅ∞ Í∞±Ïã† ÌÉÄÏù¥Î®∏ Ïû¨ÏãúÏûë
    startTokenRefreshTimer();
    
    return accessToken;
  } catch (error) {
    console.error('‚ùå ÌÜ†ÌÅ∞ Í∞±Ïã† Ïã§Ìå®:', error);
    
    // ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïò§Î•òÏù∏ÏßÄ ÌôïÏù∏
    if (detectServerConnectionError(error)) {
      notifyServerConnectionChange(false, error);
    }
    
    throw error;
  }
};

// Î°úÍ∑∏ÏïÑÏõÉ
export const logout = async () => {
  try {
    const refreshTokenStr = getRefreshToken();
    if (refreshTokenStr) {
      await apiClient.post('/auth/logout', { refreshToken: refreshTokenStr });
    }
    clearAuthData();
    stopTokenRefreshTimer();
  } catch (error) {
    console.error('‚ùå Î°úÍ∑∏ÏïÑÏõÉ Ïã§Ìå®:', error);
    // ÏÑúÎ≤Ñ Ïò§Î•òÍ∞Ä ÏûàÏñ¥ÎèÑ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Îç∞Ïù¥ÌÑ∞Îäî Ï†ïÎ¶¨
    clearAuthData();
    stopTokenRefreshTimer();
  }
};

// ÏûêÎèô ÌÜ†ÌÅ∞ Í∞±Ïã† ÌÉÄÏù¥Î®∏
let tokenRefreshTimer = null;

const startTokenRefreshTimer = () => {
  stopTokenRefreshTimer(); // Í∏∞Ï°¥ ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
  
  const token = getToken();
  if (!token) return;
  
  const remainingTime = getTokenRemainingTime(token);
  
  if (remainingTime > 5) {
    // ÎßåÎ£å 5Î∂Ñ Ï†ÑÏóê Í∞±Ïã†
    const refreshTime = (remainingTime - 5) * 60 * 1000;
    
    tokenRefreshTimer = setTimeout(async () => {
      try {
        await refreshToken();
      } catch (error) {
        // ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïò§Î•òÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞ÏóêÎßå Î°úÍ∑∏ÏïÑÏõÉ Ï≤òÎ¶¨
        if (!detectServerConnectionError(error)) {
          handleTokenExpiration('ÏÑ∏ÏÖò Í∞±Ïã†Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥Ï£ºÏÑ∏Ïöî.');
        }
      }
    }, refreshTime);
  }
};

const stopTokenRefreshTimer = () => {
  if (tokenRefreshTimer) {
    clearTimeout(tokenRefreshTimer);
    tokenRefreshTimer = null;
  }
};

// Ïï± ÏãúÏûë Ïãú ÌÜ†ÌÅ∞ ÏÉÅÌÉú ÌôïÏù∏
export const initializeAuth = async () => {
  const token = getToken();
  if (!token) {
    return false;
  }
  
  if (isTokenExpired(token)) {
    try {
      await refreshTokenSilently();
      startTokenRefreshTimer();
      return true;
    } catch (error) {
      // ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïò§Î•òÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞ÏóêÎßå Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú
      if (!detectServerConnectionError(error)) {
        clearAuthData();
      }
      return false;
    }
  } else {
    startTokenRefreshTimer();
    return true;
  }
};

// ÎÇòÎ®∏ÏßÄ Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§...
export const isModeratorForCategory = (categoryId) => {
  const user = getCurrentUser();
  return user && 
         user.role === 'ROLE_MODERATOR' && 
         user.managedCategoryIds && 
         user.managedCategoryIds.includes(Number(categoryId));
};

export const getUserLevel = () => {
  const user = getCurrentUser();
  if (!user) return 0;
  
  switch (user.role) {
    case 'ROLE_MANAGER': return 4;
    case 'ROLE_ADMIN': return 3;
    case 'ROLE_MODERATOR': return 2;
    case 'ROLE_USER': return 1;
    default: return 0;
  }
};

export const getRoleDisplayName = (role) => {
  switch (role) {
    case 'ROLE_MANAGER': return 'Îß§ÎãàÏ†Ä';
    case 'ROLE_ADMIN': return 'Í¥ÄÎ¶¨Ïûê';
    case 'ROLE_MODERATOR': return 'Í¥ÄÎ¶¨ÏûêÌöåÏõê';
    case 'ROLE_USER': return 'ÏùºÎ∞òÌöåÏõê';
    default: return 'Ïïå Ïàò ÏóÜÏùå';
  }
};

export const getTokenStatus = () => {
  const token = getToken();
  if (!token) return { valid: false, message: 'ÌÜ†ÌÅ∞ ÏóÜÏùå' };
  
  const remainingTime = getTokenRemainingTime(token);
  const expired = isTokenExpired(token);
  
  return {
    valid: !expired,
    remainingTime,
    message: expired ? 'ÌÜ†ÌÅ∞ ÎßåÎ£åÎê®' : `${remainingTime}Î∂Ñ ÎÇ®Ïùå`
  };
};

export default apiClient;