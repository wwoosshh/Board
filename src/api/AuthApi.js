import axios from 'axios';

// üåê HTTPÎ°ú Îã§Ïãú Î≥ÄÍ≤Ω (HTTPS ÎåÄÏã†)
const BASE_URL = process.env.NODE_ENV === 'production' 
  ? '/api'  // ÌîÑÎ°ùÏãú Í≤ΩÎ°úÎ°ú Î≥ÄÍ≤Ω
  : 'http://localhost:5159/api';

// Axios Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
const apiClient = axios.create({
  baseURL: BASE_URL,
});

// ÌÜ†ÌÅ∞ Í∞±Ïã† Ï§ëÏù∏ÏßÄ ÌôïÏù∏ÌïòÎäî ÌîåÎûòÍ∑∏
let isRefreshing = false;
let refreshSubscribers = [];

// ÌÜ†ÌÅ∞ Í∞±Ïã† ÎåÄÍ∏∞ Ï§ëÏù∏ ÏöîÏ≤≠Îì§ÏùÑ Ï≤òÎ¶¨ÌïòÎäî Ìï®Ïàò
const subscribeTokenRefresh = (cb) => {
  refreshSubscribers.push(cb);
};

const onRefreshed = (token) => {
  refreshSubscribers.forEach((cb) => cb(token));
  refreshSubscribers = [];
};

// JWT ÌÜ†ÌÅ∞ ÎîîÏΩîÎî© (ÎßåÎ£å ÏãúÍ∞Ñ ÌôïÏù∏Ïö©)
const decodeJWT = (token) => {
  try {
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
      return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
    }).join(''));
    return JSON.parse(jsonPayload);
  } catch (error) {
    console.error('JWT ÎîîÏΩîÎî© Ïò§Î•ò:', error);
    return null;
  }
};

// ÌÜ†ÌÅ∞ ÎßåÎ£å ÌôïÏù∏
const isTokenExpired = (token) => {
  if (!token) return true;
  
  const decoded = decodeJWT(token);
  if (!decoded || !decoded.exp) return true;
  
  const currentTime = Date.now() / 1000;
  const bufferTime = 60; // 1Î∂Ñ Î≤ÑÌçº
  
  return decoded.exp < (currentTime + bufferTime);
};

// ÌÜ†ÌÅ∞ ÎßåÎ£åÍπåÏßÄ ÎÇ®ÏùÄ ÏãúÍ∞Ñ (Î∂Ñ)
const getTokenRemainingTime = (token) => {
  if (!token) return 0;
  
  const decoded = decodeJWT(token);
  if (!decoded || !decoded.exp) return 0;
  
  const currentTime = Date.now() / 1000;
  const remainingSeconds = decoded.exp - currentTime;
  
  return Math.max(0, Math.floor(remainingSeconds / 60));
};

// ÏûêÎèô Î°úÍ∑∏ÏïÑÏõÉ Î∞è ÏïåÎ¶º
const handleTokenExpiration = (message = 'Î°úÍ∑∏Ïù∏Ïù¥ ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§. Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥Ï£ºÏÑ∏Ïöî.') => {
  console.log('üî¥ ÌÜ†ÌÅ∞ ÎßåÎ£å Ï≤òÎ¶¨:', message);
  
  // ÌÜ†ÌÅ∞ Ï†ïÎ¶¨
  clearAuthData();
  
  // ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÏïåÎ¶º
  if (window.showTokenExpiredNotification) {
    window.showTokenExpiredNotification(message);
  } else {
    alert(message);
  }
  
  // 3Ï¥à ÌõÑ Î°úÍ∑∏Ïù∏ ÌéòÏù¥ÏßÄÎ°ú Ïù¥Îèô
  setTimeout(() => {
    window.location.href = '/login';
  }, 3000);
};

// ÏöîÏ≤≠ Ïù∏ÌÑ∞ÏÖâÌÑ∞ - Authorization Ìó§Îçî Ï∂îÍ∞Ä Î∞è ÌÜ†ÌÅ∞ Ï≤¥ÌÅ¨
apiClient.interceptors.request.use(
  async (config) => {
    // Ïù∏Ï¶ùÏù¥ ÌïÑÏöîÏóÜÎäî Í≤ΩÎ°úÎäî Í±¥ÎÑàÎõ∞Í∏∞
    if (config.url.includes('/auth/')) {
      return config;
    }
    
    const token = getToken();
    
    if (token) {
      // ÌÜ†ÌÅ∞ ÎßåÎ£å Ï≤¥ÌÅ¨
      if (isTokenExpired(token)) {
        console.log('üîÑ ÌÜ†ÌÅ∞ ÎßåÎ£å Í∞êÏßÄ - ÏûêÎèô Í∞±Ïã† ÏãúÎèÑ');
        
        try {
          const newToken = await refreshTokenSilently();
          if (newToken) {
            config.headers.Authorization = `Bearer ${newToken}`;
            console.log('‚úÖ ÌÜ†ÌÅ∞ ÏûêÎèô Í∞±Ïã† ÏÑ±Í≥µ');
          } else {
            throw new Error('ÌÜ†ÌÅ∞ Í∞±Ïã† Ïã§Ìå®');
          }
        } catch (error) {
          console.error('‚ùå ÌÜ†ÌÅ∞ ÏûêÎèô Í∞±Ïã† Ïã§Ìå®:', error);
          handleTokenExpiration('ÏÑ∏ÏÖòÏù¥ ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§. Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥Ï£ºÏÑ∏Ïöî.');
          return Promise.reject(error);
        }
      } else {
        config.headers.Authorization = `Bearer ${token}`;
      }
    }
    
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// ÏùëÎãµ Ïù∏ÌÑ∞ÏÖâÌÑ∞ - ÌÜ†ÌÅ∞ ÎßåÎ£å Ïãú ÏûêÎèô Í∞±Ïã†
apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    const { config, response } = error;
    
    console.log('üî¥ API Ïò§Î•ò:', response?.status, response?.data);
    
    if (response?.status === 401 && !config._retry) {
      console.log('üîÑ 401 Ïò§Î•ò - ÌÜ†ÌÅ∞ Í∞±Ïã† ÏãúÎèÑ');
      
      if (isRefreshing) {
        // Ïù¥ÎØ∏ ÌÜ†ÌÅ∞ Í∞±Ïã† Ï§ëÏù¥Î©¥ ÎåÄÍ∏∞
        return new Promise((resolve) => {
          subscribeTokenRefresh((token) => {
            config.headers.Authorization = `Bearer ${token}`;
            resolve(apiClient(config));
          });
        });
      }

      config._retry = true;
      isRefreshing = true;

      try {
        const refreshTokenStr = getRefreshToken();
        if (!refreshTokenStr) {
          throw new Error('Refresh tokenÏù¥ ÏóÜÏäµÎãàÎã§.');
        }

        const response = await apiClient.post('/auth/refresh', { 
          refreshToken: refreshTokenStr 
        });
        const { accessToken, refreshToken: newRefreshToken } = response.data;
        
        setToken(accessToken);
        if (newRefreshToken) {
          setRefreshToken(newRefreshToken);
        }
        
        onRefreshed(accessToken);
        
        config.headers.Authorization = `Bearer ${accessToken}`;
        return apiClient(config);
      } catch (refreshError) {
        console.error('üî¥ ÌÜ†ÌÅ∞ Í∞±Ïã† Ïã§Ìå®:', refreshError);
        handleTokenExpiration('Ïù∏Ï¶ùÏù¥ ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§. Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥Ï£ºÏÑ∏Ïöî.');
        return Promise.reject(refreshError);
      } finally {
        isRefreshing = false;
      }
    }

    return Promise.reject(error);
  }
);

// ÏûêÎèô ÌÜ†ÌÅ∞ Í∞±Ïã† (ÏöîÏ≤≠ Ï†Ñ Ìò∏Ï∂ú)
const refreshTokenSilently = async () => {
  try {
    const refreshTokenStr = getRefreshToken();
    if (!refreshTokenStr) {
      throw new Error('Refresh tokenÏù¥ ÏóÜÏäµÎãàÎã§.');
    }

    const response = await axios.post(`${BASE_URL}/auth/refresh`, { 
      refreshToken: refreshTokenStr 
    });
    
    const { accessToken, refreshToken: newRefreshToken } = response.data;
    
    setToken(accessToken);
    if (newRefreshToken) {
      setRefreshToken(newRefreshToken);
    }
    
    return accessToken;
  } catch (error) {
    console.error('‚ùå ÏûêÎèô ÌÜ†ÌÅ∞ Í∞±Ïã† Ïã§Ìå®:', error);
    return null;
  }
};

// ÏÇ¨Ïö©Ïûê Îì±Î°ù (ÌöåÏõêÍ∞ÄÏûÖ)
export const register = async (userData) => {
  try {
    console.log('üìù ÌöåÏõêÍ∞ÄÏûÖ ÏöîÏ≤≠:', userData);
    const response = await apiClient.post('/auth/register', userData);
    console.log('‚úÖ ÌöåÏõêÍ∞ÄÏûÖ ÏÑ±Í≥µ:', response.data);
    return response.data;
  } catch (error) {
    console.error('‚ùå ÌöåÏõêÍ∞ÄÏûÖ Ïã§Ìå®:', error);
    throw error;
  }
};

// ÏÇ¨Ïö©Ïûê Î°úÍ∑∏Ïù∏
export const login = async (credentials) => {
  try {
    console.log('üîê Î°úÍ∑∏Ïù∏ API ÏöîÏ≤≠ ÏãúÏûë:', credentials);
    
    const response = await apiClient.post('/auth/login', credentials);
    
    console.log('üì® ÏÑúÎ≤Ñ ÏùëÎãµ ÏÉÅÌÉú:', response.status);
    console.log('üì® ÏÑúÎ≤Ñ ÏùëÎãµ Îç∞Ïù¥ÌÑ∞:', response.data);
    
    // ÏùëÎãµ Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞ ÌôïÏù∏
    const { accessToken, refreshToken, user } = response.data;
    
    console.log('üîë AccessToken ÌôïÏù∏:', accessToken ? `${accessToken.substring(0, 20)}...` : 'NULL');
    console.log('üîÑ RefreshToken ÌôïÏù∏:', refreshToken ? `${refreshToken.substring(0, 20)}...` : 'NULL');
    console.log('üë§ User ÌôïÏù∏:', user ? user.username : 'NULL');
    
    if (!accessToken) {
      throw new Error('ÏÑúÎ≤ÑÏóêÏÑú AccessTokenÏùÑ Î∞õÏßÄ Î™ªÌñàÏäµÎãàÎã§.');
    }
    
    if (!refreshToken) {
      throw new Error('ÏÑúÎ≤ÑÏóêÏÑú RefreshTokenÏùÑ Î∞õÏßÄ Î™ªÌñàÏäµÎãàÎã§.');
    }
    
    if (!user) {
      throw new Error('ÏÑúÎ≤ÑÏóêÏÑú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Î•º Î∞õÏßÄ Î™ªÌñàÏäµÎãàÎã§.');
    }
    
    // ÌÜ†ÌÅ∞Îì§ Ï†ÄÏû•
    setToken(accessToken);
    setRefreshToken(refreshToken);
    setUser(user);
    
    console.log('‚úÖ Î°úÍ∑∏Ïù∏ Ï≤òÎ¶¨ ÏôÑÎ£å');
    
    // ÏûêÎèô ÌÜ†ÌÅ∞ Í∞±Ïã† ÌÉÄÏù¥Î®∏ ÏãúÏûë
    startTokenRefreshTimer();
    
    return response.data;
  } catch (error) {
    console.error('‚ùå Î°úÍ∑∏Ïù∏ API Ïã§Ìå®:', error);
    console.error('‚ùå ÏóêÎü¨ Î©îÏãúÏßÄ:', error.message);
    console.error('‚ùå ÏùëÎãµ ÏÉÅÌÉú:', error.response?.status);
    console.error('‚ùå ÏùëÎãµ Îç∞Ïù¥ÌÑ∞:', error.response?.data);
    throw error;
  }
};

// ÌÜ†ÌÅ∞ Í∞±Ïã†
export const refreshToken = async () => {
  try {
    const refreshTokenStr = getRefreshToken();
    if (!refreshTokenStr) {
      throw new Error('Refresh tokenÏù¥ ÏóÜÏäµÎãàÎã§.');
    }

    const response = await apiClient.post('/auth/refresh', { 
      refreshToken: refreshTokenStr 
    });
    const { accessToken, refreshToken: newRefreshToken } = response.data;
    
    setToken(accessToken);
    if (newRefreshToken) {
      setRefreshToken(newRefreshToken);
    }
    
    // ÏûêÎèô ÌÜ†ÌÅ∞ Í∞±Ïã† ÌÉÄÏù¥Î®∏ Ïû¨ÏãúÏûë
    startTokenRefreshTimer();
    
    return accessToken;
  } catch (error) {
    console.error('‚ùå ÌÜ†ÌÅ∞ Í∞±Ïã† Ïã§Ìå®:', error);
    throw error;
  }
};

// Î°úÍ∑∏ÏïÑÏõÉ
export const logout = async () => {
  try {
    const refreshTokenStr = getRefreshToken();
    if (refreshTokenStr) {
      await apiClient.post('/auth/logout', { refreshToken: refreshTokenStr });
    }
    clearAuthData();
    stopTokenRefreshTimer();
  } catch (error) {
    console.error('‚ùå Î°úÍ∑∏ÏïÑÏõÉ Ïã§Ìå®:', error);
    // ÏÑúÎ≤Ñ Ïò§Î•òÍ∞Ä ÏûàÏñ¥ÎèÑ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Îç∞Ïù¥ÌÑ∞Îäî Ï†ïÎ¶¨
    clearAuthData();
    stopTokenRefreshTimer();
  }
};

// ÌÜ†ÌÅ∞ Ï†ÄÏû•/Ï°∞Ìöå/ÏÇ≠Ï†ú Ìï®ÏàòÎì§
export const setToken = (token) => {
  localStorage.setItem('accessToken', token);
  console.log('üíæ Access Token Ï†ÄÏû•Îê®');
};

export const getToken = () => {
  return localStorage.getItem('accessToken');
};

export const setRefreshToken = (token) => {
  localStorage.setItem('refreshToken', token);
  console.log('üíæ Refresh Token Ï†ÄÏû•Îê®');
};

export const getRefreshToken = () => {
  return localStorage.getItem('refreshToken');
};

export const setUser = (user) => {
  localStorage.setItem('user', JSON.stringify(user));
};

export const getCurrentUser = () => {
  const userStr = localStorage.getItem('user');
  return userStr ? JSON.parse(userStr) : null;
};

export const clearAuthData = () => {
  localStorage.removeItem('accessToken');
  localStorage.removeItem('refreshToken');
  localStorage.removeItem('user');
  console.log('üóëÔ∏è Ïù∏Ï¶ù Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†úÎê®');
};

// Ïù∏Ï¶ù Ìó§Îçî ÏÑ§Ï†ï
export const authHeader = () => {
  const token = getToken();
  return token ? { Authorization: `Bearer ${token}` } : {};
};

// ÏÇ¨Ïö©ÏûêÍ∞Ä Î°úÍ∑∏Ïù∏ÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏ (ÌÜ†ÌÅ∞ Ïú†Ìö®ÏÑ± Ìè¨Ìï®)
export const isAuthenticated = () => {
  const token = getToken();
  if (!token) return false;
  
  // ÌÜ†ÌÅ∞Ïù¥ ÎßåÎ£åÎêòÏóàÏúºÎ©¥ false Î∞òÌôò
  if (isTokenExpired(token)) {
    console.log('üî¥ ÌÜ†ÌÅ∞ ÎßåÎ£åÎê® - Ïù∏Ï¶ù Ïã§Ìå®');
    return false;
  }
  
  return true;
};

// ÏÇ¨Ïö©Ïûê Ïó≠Ìï† ÌôïÏù∏
export const hasRole = (role) => {
  const user = getCurrentUser();
  return user && user.role === role;
};

// ÏÇ¨Ïö©ÏûêÍ∞Ä Í¥ÄÎ¶¨ÏûêÏù∏ÏßÄ ÌôïÏù∏
export const isAdmin = () => {
  return hasRole('ROLE_ADMIN');
};

// ÏÇ¨Ïö©ÏûêÍ∞Ä Í¥ÄÎ¶¨Ïûê ÌöåÏõêÏù∏ÏßÄ ÌôïÏù∏
export const isModerator = () => {
  return hasRole('ROLE_MODERATOR');
};

// ÏÇ¨Ïö©ÏûêÍ∞Ä Îß§ÎãàÏ†ÄÏù∏ÏßÄ ÌôïÏù∏
export const isManager = () => {
  return hasRole('ROLE_MANAGER');
};

// ÏÇ¨Ïö©ÏûêÍ∞Ä Í¥ÄÎ¶¨Ïûê Ïù¥ÏÉÅ Í∂åÌïúÏù∏ÏßÄ ÌôïÏù∏ (Í¥ÄÎ¶¨Ïûê ÎòêÎäî Îß§ÎãàÏ†Ä)
export const isAdminOrAbove = () => {
  return hasRole('ROLE_ADMIN') || hasRole('ROLE_MANAGER');
};

// ÏÇ¨Ïö©ÏûêÍ∞Ä Í¥ÄÎ¶¨ÏûêÌöåÏõê Ïù¥ÏÉÅ Í∂åÌïúÏù∏ÏßÄ ÌôïÏù∏ (Í¥ÄÎ¶¨ÏûêÌöåÏõê, Í¥ÄÎ¶¨Ïûê, Îß§ÎãàÏ†Ä)
export const isModeratorOrAbove = () => {
  return hasRole('ROLE_MODERATOR') || hasRole('ROLE_ADMIN') || hasRole('ROLE_MANAGER');
};

// ÏÇ¨Ïö©ÏûêÍ∞Ä ÌäπÏ†ï Ïπ¥ÌÖåÍ≥†Î¶¨Ïùò Í¥ÄÎ¶¨Ïûê ÌöåÏõêÏù∏ÏßÄ ÌôïÏù∏
export const isModeratorForCategory = (categoryId) => {
  const user = getCurrentUser();
  return user && 
         user.role === 'ROLE_MODERATOR' && 
         user.managedCategoryIds && 
         user.managedCategoryIds.includes(Number(categoryId));
};

// Í∂åÌïú Î†àÎ≤® ÌôïÏù∏ (Ïà´ÏûêÎ°ú Î∞òÌôò)
export const getUserLevel = () => {
  const user = getCurrentUser();
  if (!user) return 0;
  
  switch (user.role) {
    case 'ROLE_MANAGER': return 4;
    case 'ROLE_ADMIN': return 3;
    case 'ROLE_MODERATOR': return 2;
    case 'ROLE_USER': return 1;
    default: return 0;
  }
};

// Í∂åÌïúÎ™ÖÏùÑ ÌïúÍ∏ÄÎ°ú Î≥ÄÌôò
export const getRoleDisplayName = (role) => {
  switch (role) {
    case 'ROLE_MANAGER': return 'Îß§ÎãàÏ†Ä';
    case 'ROLE_ADMIN': return 'Í¥ÄÎ¶¨Ïûê';
    case 'ROLE_MODERATOR': return 'Í¥ÄÎ¶¨ÏûêÌöåÏõê';
    case 'ROLE_USER': return 'ÏùºÎ∞òÌöåÏõê';
    default: return 'Ïïå Ïàò ÏóÜÏùå';
  }
};

// ÌÜ†ÌÅ∞ ÏÉÅÌÉú ÌôïÏù∏ (ÎîîÎ≤ÑÍπÖÏö©)
export const getTokenStatus = () => {
  const token = getToken();
  if (!token) return { valid: false, message: 'ÌÜ†ÌÅ∞ ÏóÜÏùå' };
  
  const remainingTime = getTokenRemainingTime(token);
  const expired = isTokenExpired(token);
  
  return {
    valid: !expired,
    remainingTime,
    message: expired ? 'ÌÜ†ÌÅ∞ ÎßåÎ£åÎê®' : `${remainingTime}Î∂Ñ ÎÇ®Ïùå`
  };
};

// ÏûêÎèô ÌÜ†ÌÅ∞ Í∞±Ïã† ÌÉÄÏù¥Î®∏
let tokenRefreshTimer = null;

const startTokenRefreshTimer = () => {
  stopTokenRefreshTimer(); // Í∏∞Ï°¥ ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
  
  const token = getToken();
  if (!token) return;
  
  const remainingTime = getTokenRemainingTime(token);
  
  if (remainingTime > 5) {
    // ÎßåÎ£å 5Î∂Ñ Ï†ÑÏóê Í∞±Ïã†
    const refreshTime = (remainingTime - 5) * 60 * 1000;
    
    tokenRefreshTimer = setTimeout(async () => {
      console.log('‚è∞ ÏûêÎèô ÌÜ†ÌÅ∞ Í∞±Ïã† ÏãúÏûë');
      try {
        await refreshToken();
        console.log('‚úÖ ÏûêÎèô ÌÜ†ÌÅ∞ Í∞±Ïã† ÏôÑÎ£å');
      } catch (error) {
        console.error('‚ùå ÏûêÎèô ÌÜ†ÌÅ∞ Í∞±Ïã† Ïã§Ìå®:', error);
        handleTokenExpiration('ÏÑ∏ÏÖò Í∞±Ïã†Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥Ï£ºÏÑ∏Ïöî.');
      }
    }, refreshTime);
    
    console.log(`‚è∞ ÌÜ†ÌÅ∞ ÏûêÎèô Í∞±Ïã† ÌÉÄÏù¥Î®∏ ÏÑ§Ï†ï: ${Math.floor(refreshTime / 1000 / 60)}Î∂Ñ ÌõÑ`);
  }
};

const stopTokenRefreshTimer = () => {
  if (tokenRefreshTimer) {
    clearTimeout(tokenRefreshTimer);
    tokenRefreshTimer = null;
    console.log('‚è∞ ÌÜ†ÌÅ∞ Í∞±Ïã† ÌÉÄÏù¥Î®∏ Ï†ïÏßÄ');
  }
};

// Ïï± ÏãúÏûë Ïãú ÌÜ†ÌÅ∞ ÏÉÅÌÉú ÌôïÏù∏
export const initializeAuth = async () => {
  const token = getToken();
  if (!token) {
    console.log('üîç Ï¥àÍ∏∞Ìôî: ÌÜ†ÌÅ∞ ÏóÜÏùå');
    return false;
  }
  
  if (isTokenExpired(token)) {
    console.log('üîÑ Ï¥àÍ∏∞Ìôî: ÌÜ†ÌÅ∞ ÎßåÎ£å - ÏûêÎèô Í∞±Ïã† ÏãúÎèÑ');
    try {
      await refreshTokenSilently();
      startTokenRefreshTimer();
      console.log('‚úÖ Ï¥àÍ∏∞Ìôî: ÌÜ†ÌÅ∞ Í∞±Ïã† ÏÑ±Í≥µ');
      return true;
    } catch (error) {
      console.error('‚ùå Ï¥àÍ∏∞Ìôî: ÌÜ†ÌÅ∞ Í∞±Ïã† Ïã§Ìå®');
      clearAuthData();
      return false;
    }
  } else {
    console.log('‚úÖ Ï¥àÍ∏∞Ìôî: ÌÜ†ÌÅ∞ Ïú†Ìö®');
    startTokenRefreshTimer();
    return true;
  }
};

export default apiClient;